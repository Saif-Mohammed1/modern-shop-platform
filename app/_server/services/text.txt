 private async verifyInventoryLevels(
    userCart: CartItemsType[],
    transaction: mongoose.ClientSession
  ): Promise<void> {
    const products = await ProductModel.find({
      _id: { $in: userCart.map((i) => i._id) },
    }).session(transaction);

    const insufficientStock = userCart.filter((item) => {
      const product = products.find((p) => p._id.equals(item._id))!;
      return product.stock < item.quantity;
    });

    if (insufficientStock.length > 0) {
      throw new AppError(
        `Insufficient stock for ${insufficientStock.length} items`,
        409
      );
    }
  }

  // private async handleOrderFailure(
  //   session: Stripe.Checkout.Session,
  //   error: Error
  // ): Promise<void> {
  //   const failureData: FailedOrderData = {
  //     sessionId: session.id,
  //     userId: session.client_reference_id || "unknown",
  //     error: error.message,
  //     metadata: session.metadata,
  //     products: JSON.parse(session.metadata?.products || "[]"),
  //   };

  //   // Record failed order
  //   await OrderModel.create([
  //     {
  //       payment: {
  //         method: "stripe",
  //         transactionId: session.payment_intent as string,
  //       },
  //       status: OrderStatus.Failed,
  //       failureReason: error.message,
  //       failedAt: new Date(),
  //       metadata: failureData,
  //     },
  //   ]);

  //   // Release resources
  //   await this.releaseReservedInventory(session.metadata.idempotencyKey);
  //   await this.notifyAdmins(failureData);
  // }

  // private async releaseReservedInventory(
  //   idempotencyKey: string
  // ): Promise<void> {
  //   const reservationKey = `reservation:${idempotencyKey}`;
  //   const products = await redis.get(reservationKey);

  //   if (products) {
  //     try {
  //       const parsedProducts = JSON.parse(products);
  //       await ProductModel.bulkWrite(
  //         parsedProducts.map((p: any) => ({
  //           updateOne: {
  //             filter: { _id: p._id },
  //             update: { $inc: { reserved: -p.quantity } },
  //           },
  //         }))
  //       );
  //     } catch (error) {
  //       console.error("Inventory release failed:", error);
  //     }
  //     await redis.del(reservationKey);
  //   }
  // }
  // private async updateProductSales(
  //   user: IUser,
  //   userCart: CartItemsType[],
  //   session: mongoose.ClientSession
  // ): Promise<void> {
  //   try {
  //     const bulkOps = userCart.map((item) => ({
  //       updateOne: {
  //         filter: { _id: new mongoose.Types.ObjectId(item._id) },
  //         update: {
  //           $inc: {
  //             sold: item.quantity,
  //             reserved: -item.quantity,
  //             stock: -item.quantity,
  //           },
  //         },
  //       },
  //     }));

  //     const result = await ProductModel.bulkWrite(bulkOps, { session });

  //     if (result.modifiedCount !== userCart.length) {
  //       throw new AppError("Partial inventory update failed", 500);
  //     }
  //   } catch (error) {
  //   await this.productService.logAction(
  //     AuditAction.INVENTORY_RESERVATION_PARTIAL,
  //     "BATCH_UPDATE",
  //     user._id,
  //        userCart.map((item) => ({
  //           field: "sold/reserved/stock",
  //           productId: item._id,
  //           quantity: item.quantity,
  //           changeType: "MODIFY",
  //         })),
  //         context: {
  //           error: error instanceof Error ? error.message : "Unknown error",
  //         },

  //     );
  //     throw error;
  //   }
  // }

  // private async getAdminIds(): Promise<string[]> {
  //   const admins = await UserModel.find({ role: "admin" }).select("_id").lean();
  //   return admins.map((a) => a._id.toString());
  // }

  // helper methods
  // private async handlePartialReservationFailure(
  //   user: IUser,
  //   failedProducts: Array<{ _id: mongoose.Types.ObjectId; quantity: number }>
  // ): Promise<void> {
  //   // 1. Log audit entry

  //   await this.productService.logAction(
  //     AuditAction.INVENTORY_RESERVATION_PARTIAL,
  //     "BATCH_UPDATE",
  //     user._id,
  //     failedProducts.map((p) => ({
  //       field: "reserved",
  //       productId: p._id,
  //       quantity: p.quantity,
  //       changeType: "MODIFY",
  //     })),
  //     "127.0.0.1", // Replace with actual IP address
  //     "user-agent-string" // Replace with actual user agent
  //   );

  //   // 2. Notify admins
  //   const adminNotification = {
  //     type: "INVENTORY_RESERVATION_PARTIAL",
  //     userId: user._id.toString(),
  //     failedProducts: failedProducts.map((p) => ({
  //       productId: p._id.toString(),
  //       quantity: p.quantity,
  //     })),
  //     timestamp: new Date(),
  //   };

  //   await NotificationQueue.add({
  //     type: "ADMIN_ALERT",
  //     recipients: await this.getAdminIds(),
  //     content: {
  //       subject: "Partial Inventory Reservation Failure",
  //       body: JSON.stringify(adminNotification),
  //       priority: "high",
  //     },
  //   });

  //   // 3. Update user's cart
  //   await this.userCartService.removeItemsFromCart(
  //     user._id.toString(),
  //     failedProducts.map((p) => p._id.toString())
  //   );
  // }

    private async handleCheckoutSuccess(session: Stripe.Checkout.Session) {
    const lockKey = `order:${session.id}`;
    const locked = await this.acquireLock(lockKey);
    if (!locked) throw new AppError("Concurrent order processing", 409);

    const transaction = await mongoose.startSession();
    transaction.startTransaction();

    try {
      const user = await UserModel.findById(session.client_reference_id)
        .session(transaction)
        .orFail(new AppError("User not found", 404));

      const shippingInfo = this.parseShippingInfo(
        session.metadata?.shippingInfo || ""
      );
      const userCart = await this.userCartService.getMyCart(
        user._id.toString()
      );

      await this.verifyInventoryLevels(userCart, transaction);
      const order = await this.createOrderFromSession(
        session,
        user,
        shippingInfo,
        userCart,
        transaction
      );

      await this.updateProductSales(userCart, transaction);
      await this.userCartService.clearCart(user._id.toString(), transaction);

      await this.sendOrderConfirmation(user, order, transaction);
      await transaction.commitTransaction();
    } catch (error) {
      await transaction.abortTransaction();
      await this.handleOrderFailure(session, error as Error);
      throw error;
    } finally {
      await transaction.endSession();
      await this.releaseLock(lockKey);
    }
  }
 private async createOrderFromSession(
    session: Stripe.Checkout.Session,
    user: IUser,
    shippingInfo: ShippingInfoDto,
    userCart: CartItemsType[],
    transaction: mongoose.ClientSession
  ) {
    try {
      const productIds = userCart.map((i) => i._id);
      const products = await ProductModel.find({ _id: { $in: productIds } })
        .session(transaction)
        .lean();

      if (products.length !== productIds.length) {
        const missingIds = productIds.filter(
          (id) => !products.some((p) => p._id.equals(id))
        );
        throw new AppError(`Missing products: ${missingIds.join(", ")}`, 404);
      }

      const orderItems = userCart.map((item) => {
        const product = products.find((p) => p._id.equals(item._id))!;
        return {
          productId: product._id,
          name: product.name,
          price: product.price,
          discount: product.discount,
          quantity: item.quantity,
          sku: product.sku,
          attributes: product.attributes,
          shippingInfo: product.shippingInfo,
          finalPrice: this.calculateFinalPrice(
            product as IProduct,
            item.quantity
          ),
        };
      });

      const [order] = await OrderModel.create(
        [
          {
            userId: user._id,
            items: orderItems,
            shippingAddress: shippingInfo,
            payment: {
              method: "stripe",
              transactionId: session.payment_intent as string,
            },
            status: OrderStatus.Processing,
            invoiceId: session.invoice as string,
            invoiceLink: session.invoice_url || "",
            subtotal: session.amount_subtotal
              ? session.amount_subtotal / 100
              : 0,
            tax: session.total_details?.amount_tax
              ? session.total_details.amount_tax / 100
              : 0,
            total: session.amount_total ? session.amount_total / 100 : 0,
            currency: session.currency?.toUpperCase() || "USD",
          },
        ],
        { session: transaction }
      );

      return order;
    } catch (error) {
      await this.handleOrderFailure(session, error as Error);

      throw error;
    }
  }